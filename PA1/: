#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include "shell_list.h"
//#####################################################################
Node *List_Load_From_File(char *filename)
{	
	int size;
	// Use fopen to open the file for read
	// Return NULL address if fopen fails
	FILE *file = fopen(filename, "rb");
	if(file == NULL)
	{
		return NULL;
	}

	// Use fseek to go to the end of the file
	// Check whether fseek fails
	// If fseek fails, fclose and return NULL address
	size = fseek(file, 0, SEEK_END);
	if(size != 0) 
	{
		fclose(file);
		return NULL;
	}

	// Use ftell to determine the size of the file
	// The number of integers is the file's size divided by 
	// Size of long
	size = ftell(file) / sizeof(long);
	
	// Use fseek to go back to the begining of the file
	fseek(file, 0, SEEK_SET);

	//STORE FILE AS LINKED LIST
	Node* temp = malloc(sizeof(Node));
	Node* head = NULL;
	Node* tail = NULL;

	while(fread(temp, sizeof(long), 1, file))
	{
		if(head == NULL)
		{
			head = malloc(sizeof(Node));
			tail = head;
		}
		else 
		{
			tail->next = malloc(sizeof(Node));
			tail = tail->next;
		}
		tail->value = temp->value;
		tail->next = NULL;
	}

	// fclose file, Return address of head
	fclose(file);
	return head;
}
//#####################################################################

int List_Save_To_File(char *filename, Node *list)
{
	// Use fopen to open the file for read
	// Return NULL address if fopen fails
	FILE * file = fopen(filename, "wb");
	if(file == NULL)
	{
		return 0;
	}

	// WRITE LIST INTO FILE
	int count = 1;
	Node *head = list;
	while(head != NULL)
	{
		fwrite(head, sizeof(long), 1, file);
		head = head->next;
		count++;
	}
	
	fclose(file);
	
	return count;
}
//#####################################################################
//Returns Value of Node at a given Index
int getNthNodeValue(Node *head, int index)
{
	Node* current = head;
	int count = 0;
	while(current != NULL)
	{
		if (count == index)
		{
			return (current->value);
		}
		count++;
		current = current->next;
	}
}

//Returns Address of Node at a given Index
Node *getNthNodeAddress(Node *head, int index)
{
	Node* current = head;
	int count = 0;
	while(current != NULL)
	{
		if (count == index)
		{
			return current;
		}
		count++;
		current = current->next;
	}
}

//get size of Linked list
int getCount(Node* head)
{
	int count = 0;
	Node* current = head;
	while(current != NULL)
	{
		count++;
		current = current->next;
	}
	return count;
}

//free Linked list
void deleteList(Node **head)
{
	Node *current = *head;
	Node *next = NULL;

	while (current != NULL)
	{
		next = current->next;
		free(current);
		current = next;
	}
	*head = NULL;
}

// add node to Linked list
void addNode(Node **head, int val)
{
	Node* newNode = malloc(sizeof(Node));
	newNode->value = val;
	newNode->next = NULL;

	//if head is NULL, it is an empty list
	if(*head == NULL)
	{
		*head = newNode;
	}
	//Otherwise, find the last node and add the newNode
	else
	{
		Node *lastNode = *head;
		//last node's next address will be NULL.
		while(lastNode->next != NULL)
		{
			lastNode = lastNode->next;
		}
		lastNode->next = newNode;
	}
}

//INSERTIONSORT ALGORITHM
void insertionSort(Node *head)
{
	Node* sorted = NULL;
	Node* current = head;

	while(current != NULL) 
	{
		Node* next = current->next;
		Node* newnode = current;
		if(sorted == NULL || sorted->value >= newnode->value)
		{
			newnode->next = sorted;
			sorted = newnode;
		}
		else
		{
			Node* current = sorted;
			while(current->next != NULL && current->next->value < newnode->value)
			{
				current = current->next;
			}
			newnode->next = current->next;
			current->next = newnode;
		}
		current = next;
	}
	head = sorted;
}

int getNumSublists(int k, int size)
{
	int num_sublists;
	int product = 1;
	int y;
	for(y = 1; product < size; y++)
	{
		product = k * y;
	}	
	product = product - k;
	return	num_sublists = size - product;

}
//printlist
void printList(Node *head)
{
    Node *temp = head;

    //iterate the entire linked list and print the data
    while(temp != NULL)
    {
         printf("%d->", temp->value);
         temp = temp->next;
    }
    printf("NULL\n");
}

//#####################################################################
//SHELLSORT ALGORITHM
Node *List_Shellsort(Node *list, long *n_comp)
{
	// 1. Acquire Size and K Value
	int size = getCount(list);
	int k = 1;
  	while(k <= size)
  	{
    	k = (3 * k) + 1;
  	}
 	k = (k - 1)/3;
    
	Node *OGhEAD = list;    
	//2. sort the linked list for every k > 0
	while(k > 0)
	{
		// 3a. Determine how many sublists are needed
		int num_sublists = getNumSublists(k,size);
        
		// 3b. Create each sublist
		printf("Number of Sublists: %d\n", num_sublists);
		
		if (k == 1)
		{
			insertionSort(list);
		}
		else 
		{
		int x;
		for(x = 1; x <= num_sublists; x++)
        {
			//4. allocate memory for sublist Nodes
			Node *listHead = NULL;

			//5. store every k gap value into sublist
			int i;
			for(i = 0; i < size; i+=k)
			{
				int val = getNthNodeValue(OGhEAD, i);
				addNode(&listHead, val);
			}
			printf("\n Stored List:\n");
			printList(listHead);	
			//6. sort the sublist using insertionSort
			insertionSort(listHead);
			printf("Sorted List:\n");
			printList(listHead);

			/*	
			//7. put back sorted sublist
			int j;
			Node *Start = listHead;
			for(j = 0; j < size; x+=k)
			{
				Node* replace = getNthNodeAddress(OGhEAD, j);
				Start->value = replace->value;
				Start = Start->next;
			}
			*/
			deleteList(&listHead);
			printList(listHead);	
			OGhEAD = OGhEAD->next;
			
		}
		}
    	k = (k - 1)/3;
	}
	return OGhEAD;
}






